% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.gplsvcm.R
\name{fit.gplsvcm}
\alias{fit.gplsvcm}
\title{gplSVCM: Generalized Partially Linear Spatially Varying Coefficients Models}
\usage{
fit.gplsvcm(V, Tr, d, r, Y, S, Z, X, family, n.layer = 2, se = FALSE, ns = 2)
}
\arguments{
\item{V}{The nV by two matrix of vertices of a triangulation, where nV is the
number of vertices. Each row is the coordinates for a vertex.}

\item{Tr}{The triangulation matrix of dimention nT by three, where nT is the
number of triangles in the triangulation. Each row is the indices of vertices in V.}

\item{d}{The degree of piecewise polynomials – default is 5, and usually d
is greater than one. -1 represents piecewise constant.}

\item{r}{The smoothness parameter – default is 1, and 0 ≤ r < d.}

\item{Y}{A vector of response variable.}

\item{S}{A matrix containing the locations of new points.}

\item{Z}{A matrix containing the values of model covariates with
constant effects.}

\item{X}{A matrix containing the values of model covariates with
spatially varying effects.}

\item{family}{This is a family object specifying the distribution and link
to use.}

\item{n.layer}{Number of layers of triangles used to define the neighborhood.}

\item{se}{An indicator of whether to return the estimated variance-covariance matrix of estimator of the linear components.}

\item{ns}{Number of parallel cores to use.}
}
\description{
fit.gplsvcm(): This function fits a GPLSVCM based on divide-and-conquer and domain decomposition methods.
}
\examples{
# Triangulation
data("V.2"); data("Tr.2");
V = V.2; Tr = Tr.2;
Triangulation::TriPlot(V, Tr)
# Parameters
d <- 2; r <- 1;
family.name <- "gau"
if (family.name == "bin") {
family <- binomial()
} else if (family.name == "gau") {
family <- gaussian()
}
n.layer = 2; ns <- 2;
n <- 10000;
dat <- dat.generator(n, V.2, Tr.2, family.name)
Y <- dat$y
X <- cbind(dat$x1, dat$x2)
Z <- cbind(dat$z1, dat$z2, dat$z3)
S <- cbind(dat$s1, dat$s2)
mfit <- fit.gplsvcm(V, Tr, d, r,
Y = Y, X = X, Z = Z, S = S,
family = family, n.layer = n.layer, se = TRUE, ns = ns)
# Results: eta.hat and its variance-covariance matrix
mfit$eta.hat
mfit$eta.hat.cov

# Generate population grid points
uu.grid <- seq(-0.9, 3.4, 0.02)
vv.grid <- seq(-0.9, 0.9, 0.02)
S.grid <- as.matrix(expand.grid(uu.grid, vv.grid))
# plots of estimated coefficient functions
plots.gplsvcm(mfit, S.grid)

}
